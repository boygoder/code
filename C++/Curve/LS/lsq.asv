clear; %清除上次运行的所有变量
close all; %关闭上次运行的子窗口

%=====下面读取原图并显示
Gray = imread('2.bmp');
if ndims(Gray) == 3
    Gray = rgb2gray(Gray);
end
figure(1),imshow(Gray) %将图像显示出来
Image = im2double(Gray);%将图片的数据类型从unit8变为double型，只有这样回叙才能进行处理

%=====输入源图像大小
[image_y_max, image_x_max] =  size(Image);

%将曲线宽度降为1像素
for x  =  1 : image_x_max 
    white = false;
    for y =  image_y_max :-1 : 1
        v = x;
        u = -y + image_y_max + 1;
        if (Image(u,v) == 1)
            if (white == false)
                white = true;
            else
                Image(u,v) = 0;
            end
        else
            white = false;
        end
    end
end
figure,imshow(Image)

%找到交点所在列，按上面处理方式，该列只有一个白色点
count = zeros(image_x_max,1);
for i =  1 : image_x_max
    count(i) = sum(Image(:,i)~=0);
end
%disp(count);
num_curve = max(count);
max_column = find(count == num_curve);
inter_column =  1;
for i = max_column(1) : 1: image_x_max
    if  (count(i) < num_curve)
        inter_column = i;
        break;
    end
end

Image_cut = Image( :, max_column(1) :inter_column -1);

%figure,imshow(Image_cut);

[imagecut_y_max,imagecut_x_max] = size(Image_cut);

Curves = zeros(imagecut_x_max,2,num_curve);
for x =  1 : imagecut_x_max
    curve_id = 0;
    for y =  imagecut_y_max : -1 : 1
        v = x + max_column(1) - 1;
        u = -y + imagecut_y_max + 1;
        if (Image_cut(u,x) == 1)
            curve_id  = curve_id + 1;
            Curves(x,1,curve_id) = v;
            Curves(x,2,curve_id) = y;
        end
    end
end
%disp(Curves(1,1,:))

parameter = zeros(num_curve,3);
for i = 1 : num_curve
    fun = @(t)( t(1)*cosh( (Curves(:,1,i)-t(2))./t(1) ) + t(3) - Curves(:,2,i));
    parameter_initial = [imagecut_y_max,imagecut_x_max,-imagecut_y_max];                              % 待辨识参数的初值
    parameter(i,:) = lsqnonlin(fun,parameter_initial);               % 非线性拟合
    
    % 将拟合结果代入函数
    x_fit = zeros(image_x_max);
    y_fit = zeros(image_x_max);
    for x = 1 : image_x_max
        t = parameter(i,:);
        x_fit(x) = x;
        y_fit(x) = t(1)*cosh((x - t(2))./ t(1)) + t(3);
    end

%     figure
%     plot(Curves(:,1,i),Curves(:,2,i),'LineWidth',3,'Color','yellow');
%     hold on
%     plot(x_fit,y_fit,'LineWidth',3,'Color','red');
    
% Imageshow = Image;
%     for  x  = 1 : image_x_max
%         y = y_fit(x);
%         if (y >=1) && (y <= image_y_max - 1)
%             v = x ;
%             u = -y + image2_y_max;
%             u = round(u);
%             Imageshow(u,v)  = 1;
%         end
%  end
% figure,inshow(Imageshow);
end

    
%将点分类到最近的曲线

CurveClassfication = zeros(image_x_max,2,num_curve);
for  i  = 1 : image_x_max
    for j =  image_y_max : -1 : 1
        v = i;
        u = -j + image_y_max + 1;
        if (Image(u,v) == 1)
            y_distance = zeros(num_curve);
            for k =  1 : num_curve
                t = parameter(k,:);
                x = i;
                y_fit = t(1)*cosh((x - t(2))./ t(1)) + t(3);
                y_distance(k) = abs(y_fit - j);
            end
            %寻找离这个点最近的曲线
            min_distance = min(y_distance);
            curve_id = find(y_distance == min_distance);
            CurveClassfication(i,1,curve_id) = i;
            CurveClassfication(i,2,curve_id) = j;
        end
    end
end

parameter_update = zeros(num_curve,3);
for i =  1 : num_crurve
    curve_x = CurveClassfication()
end

%=====下面进行边缘提取并显示
%  I_edge = edge(Image,'canny'); %边缘提取，采用Sobel方法
%  %figure(2),imshow(I_edge) %将结果图像显示出来
% 
% x_real = zeros(image_x_max);
% y_real = zeros(image_x_max);
% index = 1;
% for x =  1 : image_x_max -1
%     is_found = false;
%     for y = 1 : image_y_max - 1
%         if (is_found)
%             break;
%         end
%         v = x;
%         u = -y + image_y_max; 
%         if (I_edge(u,v) == 1)
%             x_real(index) = x;
%             y_real(index) = y;
%             index = index + 1;
%             is_found = true;
%         end
%     end
% end
% x_real =  x_real(1:index-1);
% y_real = y_real(1:index-1);
% 
% 
% fun = @(t)( t(1)*cosh( (x_real-t(2))./t(1) ) + t(3) - y_real);
% Parameter = [image_y_max,image_x_max,-image_y_max];                              % 待辨识参数的初值
% t = lsqnonlin(fun,Parameter);               % 非线性拟合
% 
% % 将拟合结果代入函数
% x_fit = zeros(image_x_max);
% y_fit = zeros(image_x_max);
% for x = 1 : image_x_max
%     x_fit(x) = x;
%     y_fit(x) = t(1)*cosh((x - t(2))./ t(1)) + t(3);
% end
% 
% figure
% plot(x_real,y_real,'LineWidth',3,'Color','yellow');
% hold on
% plot(x_fit,y_fit,'LineWidth',3,'Color','red');
% 
% 
% 
% for  i  = 1 : image_x_max
%     x = x_fit(i);
%     y = t(1)*cosh( (x - t(2))/ t(1) ) + t(3);
%     if (y >=1) && (y <= image_y_max - 1)
%         v = x ;
%         u = -y + image_y_max;
%         u = round(u);
%         Image(u,v)  = 1;
%     end
%  end
%  
% figure, imshow(Image)




