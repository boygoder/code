## 图像处理与网格简化

### 1.颜色转换

上面图片是日落的图片，下面的图片是日出的图片。我们希望将日出的颜色转换为日落的颜色。
(b)图像提供颜色，称为目标图像。
(a)图像提供要处理的图像，称为源图像。

### 2. 颜色空间

图片变换是在颜色空间中进行的。
当图像使用经典的RGB三通道颜色空间表示时，不同通道的值之间存在相关性。
这意味着如果我们想以连贯的方式改变像素颜色的话，我们必须依次地修改所有颜色通道。我们想要的是一个通道之间没有相关性的正交颜色空间。

$l \alpha \beta$颜色空间：三个通道分别代表：亮度，黄蓝通道，红绿通道。


### 3.均值与方差变换

将图片像素从RGB颜色空间变换到$l \alpha \beta$颜色空间。

在$l \alpha \beta$颜色空间中，做均值与反差变换：

- 将源图像每一像素的颜色减去源图像的颜色均值。   
- 乘以目标图像的标准差与源图像的标准差的比例。
- 将源图像每一像素的颜色加上目标图像的颜色均值。

最后，变换回RGB颜色空间，就可以完成颜色转换。

然后我们来看图像扭转。

### 4.图像扭转

图像扭转用来修改图像的局部，比如蒙娜丽莎的面部表情。

### 5.算法描述

我们选取n对锚点$(p_{i},q_{i})$作为输入,$p_{i}$是在源图像中选取的，$q_{i}$则是$p_{i}$在图像扭转之后应该在的位置。

算法的输出就是一个连续映射f，满足$f(p_{i}) = q_{i}$。

将映射f作用在所有像素点上，并对产生的缝隙进行填补，就完成了图像扭转。

根据映射f类型的不同，算法有IDW和RBF两种。



### 6.IDW算法

 IDW 的意思是反距离加权插值。
 对于每对锚点，寻找局部近似函数$f_{i,x}$和$f_{i,y}$，将锚点$p_{i}$映射到对应的$q_{i}$的坐标分量。

 最终的坐标变换公式就是局部近似函数的加权和。

 $$(p) = \sum\limits_{i=1}^{n} \omega_{i}(p) (f_{i,x}(p),f_{i,y}(p))$$

权重函数$w_{i}$需要满足这三个条件，$w_{i}(p_{i}) = 1$,公式为$\sigma_{i}$除以$\sigma$函数的和。那么$\sigma$函数就是距离的倒数。


### 7.IDW算法

局部近似函数选为线性函数，比如$f_{i,x}(p) = x_{i}^{'} + (p - p_{i})T_{i}$。


$T_{i}$是未知的系数，我们希望选取$T_{i}$使误差函数最小。

下面来看RBF算法。

### 8.RBF算法
RBF算法中的局部近似函数取的是径向基函数。

变换公式中$g_{i}$就是径向基函数，$g_{i}(d) = (d^2 + r_{i}^{2})^{1/2}$,$r_{i}$是锚点$p_{i}$与其他锚点的最小距离。

权重$\alpha_{i}$通过求解$f(p_{i}) = q_{i}$得到。

### 9. 效果展示

可以看出达到了预期的效果。

下一部分内容是网格简化内容。

### 10.网格简化

3D模型的表面可以由三角网格表示。当模型在远处或快速移动时，渲染质量的好坏对观感的影响比较小，可以降低渲染精度来提高渲染效率。

这就涉及到使用网格简化算法。

### 11.QEM网格简化算法

QEM是一种网格简化算法，算法步骤如下：

- 对所有初始的顶点计算Q矩阵，Q矩阵是后续用来计算误差的。
- 取出模型中所有的有效点对。
- 对每对有效点对，计算收缩点对的代价，从而计算出最优收缩点$\hat{v}$。
- 依次收缩代价最小的点对，直至模型满足要求。

### 12. (1.对所有初始的顶点计算Q矩阵)

每个顶点都是一组三角形的交点，每个三角形确定了一张平面。 我们将每个顶点与一组平面相关联，将顶点相对于该组平面的误差定义为顶点与平面距离的平方和。

p向量是一张平面的方程系数，$a^2 + b^2 + c^2  = 1$。
每个$K_{p}$矩阵对应一张平面，Q矩阵就是这一组中所有平面矩阵的和。

### 13.(2.取出所有的有效点对)

我们说一对点$(v_{1},v_{2})$是有效对，如果：
- $(v_{1},v_{2})$是一条边的两个点。
- 或者$||v_{1} - v_{2} || < t$，t为选定的阈值。

第二个条件是处理不连通的模型，收缩本没有边但距离很近的点对。如果没有第二个条件，那么在简化网格时，本来相邻很近的点会被拉远，此时可能会形成较大的空洞。

### 14.(3.对每对有效点对，计算最优收缩点$\hat{v}$，以及收缩有效点对的代价。)

当我们将$(v_{1},v_{2})$收缩为$v^{*}$后，定义$v^{*}$对应的平面为$v_{1}、v_{2}$平面的并集。$v^{*}$的Q矩阵定义为$Q_{1}、Q_{2}$矩阵的和。

收缩$v_{1}、v_{2}$有效对的代价定义为$v^{*}$与对应平面的误差，也就是距离的平方和。

最优收缩点就是使得代价最小的点，也就是使得收缩之后，和原来模型的差距最小。

### 15.(4.依次收缩代价最小的点对，直至模型满足要求)

可以看出在三角形个数逐渐减少时，模型的细节在减少。

最后一部分的内容是边缘提取，我会介绍几个边缘提取算子。

### 16.Sobel算子是一种用于边缘检测的离散微分算子。
Sobel算子计算像素点上下、左右邻点灰度的加权差，根据在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。

Sobel卷积因子可以在x方向，y方向各有一个矩阵。
将卷积因子与图像做平面卷积，通过$G = \sqrt{G_{x}^{2} + G_{y}^{2}}$计算像素的梯度，将梯度值超过阈值的点标记为边缘点。

### 17.Sobel边缘提取

Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素，当对精度要求不是很高时，可以使用。

### 18.Canny边缘检测

Canny边缘检测算法可以分为以下5个步骤：
-  使用高斯滤波器，以平滑图像，滤除噪声。
 高斯滤波器其实就是对灰度做一个平均。
 高斯卷积核大小的选择将影响Canny检测器的性能。卷积核越大，检测器对噪声的敏感度越低，但是边缘检测的定位误差也将略有增加。
- 计算图像中每个像素点的梯度强度和方向。
 与Sobel算子类似，$G = \sqrt{G_{x}^{2} + G_{y}^{2}}$,$\theta = arctan(G_{y}/G_{x})$。
	
### 19.Canny边缘检测

- 应用非极大值抑制，以将局部最大值之外的梯度值抑制为0。
	1. 将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。
	2. 如果当前像素的梯度强度最大，则该像素点保留为边缘点，否则该像素点将被抑制。
- 应用双阈值检测来确定真实的和潜在的边缘。
	1. 梯度值高于高阈值，标记为强边缘。
	2. 梯度值小于高阈值并且大于低阈值，标记为弱边缘。
	3. 梯度值小于低阈值，则会被抑制。

- 通过抑制孤立的弱边缘最终完成边缘检测。
	强边缘已经被确定为边缘。对于弱边缘，如果与强边缘连接，那么归为边缘；否则，弱边缘会被抑制。
	
### 20. Canny边缘检测
 Canny方法不容易受噪声干扰，能够检测到真正的弱边缘，做到边缘的像素宽度为1。
 
### 21. Laplacian算子}
Laplacian算子是二阶微分算子。
梯度的散度。
其实就是Laplace算子，不过是离散形式的。
$$
\begin{aligned}
&\Delta f = \frac{\partial^{2} f}{\partial x^2} + \frac{\partial^{2} f}{\partial y^2} \\
&\frac{\partial^{2} f}{\partial x^2} = f(x+1,y) - 2f(x,y) + f(x-1,y) \\
&\frac{\partial^{2} f}{\partial y^2} = f(x,y+1) - 2f(x,y) + f(x,y-1) 
\end{aligned}
$$
写作卷积模板：
$$
\Delta f \approx
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
$$

### 22.Laplacian算子

Laplacian对于噪声比较敏感，会产生不连续的边缘，很少用于边缘检测。可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域，从而实现图像锐化。

